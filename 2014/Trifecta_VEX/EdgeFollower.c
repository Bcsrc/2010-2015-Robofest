#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ir1,            sensorLineFollower)
#pragma config(Sensor, in2,    ir2,            sensorLineFollower)
#pragma config(Sensor, in3,    ir3,            sensorLineFollower)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           motorA,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           motorB,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           motorC,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_3, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Moving Forward -                                         *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs your robot to move forward at full power for three seconds.  There is a    *|
|*  two second pause at the beginning of the program.                                                 *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Power levels that can be assigned to a motor port range from -127 (full reverse) to         *|
|*        127 (full forward).                                                                         *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor Port 2        rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor Port 3        leftMotor           VEX 3-wire module     Left side motor                   *|
\*-----------------------------------------------------------------------------------------------4246-*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
#define R 112 //mm

#define COUNT_PER_REV  627.2
#define PI 3.14159
#define D_WHEEL (2.75*25.4)  // in mm
#define REV_2_DIST  ((PI * D_WHEEL) / COUNT_PER_REV)

void driveX(int vx)
{
	motor[motorA] = -vx/2;
	motor[motorB] = -vx/2;
	motor[motorC] =  vx;

}
void driveXY(long vx, long vy)
{
	motor[motorA] = -vx/2 - (vy*866)/1000;;
	motor[motorB] = -vx/2 + (vy*866)/1000;
	motor[motorC] =  vx;
}
void driveXYT(long vx, long vy, long vt)
{
	motor[motorA] = -vx/2 - (vy*866)/1000 + vt;
	motor[motorB] = -vx/2 + (vy*866)/1000 + vt;
	motor[motorC] =  vx + vt;
}

int distX(bool reset)
{
	static int encA, encB, encC ;
	int dA, dB, dC ;
	if (reset)
	{
		encA = -nMotorEncoder[motorA] ;
		encB = -nMotorEncoder[motorB] ;
		encC = -nMotorEncoder[motorC] ;
	}
	dA = (int)REV_2_DIST ;
	dA = (-nMotorEncoder[motorA] - encA)*REV_2_DIST ;
	dB = (-nMotorEncoder[motorB] - encB)*REV_2_DIST ;
	dC = (-nMotorEncoder[motorC] - encC)*REV_2_DIST ;

	return -dA/3 - dB/3 + 2*dC/3 ;
}
void driveY(long vy)
{
	motor[motorA] = -(vy*866)/1000;
	motor[motorB] =  (vy*866)/1000;
	motor[motorC] =  0;

}
void stopAll()
{
	motor[motorA] = 0;
	motor[motorB] = 0;
	motor[motorC] = 0;

}
void pivotA(int v)
{
	motor[motorB] = v;
	motor[motorC] = v;

}
void pivotB(int v)
{
	motor[motorA] = v;
	motor[motorC] = v;

}
task main()
{

	while(nLCDButtons == 0) {}

	wait1Msec(2000);
	while(true)
	{
		int ey;
		int et;
		int s1 = sensorValue[ir1];
		int s2 = sensorValue[ir2];
		ey = (s1 + s2)/2 - 2000;
		et = (s2 - s1)/2;
		driveXYT(30,-ey/150,-et/150 );
	}
//	driveY(30);
//	while(sensorValue[ir1]< 2000 && sensorValue[ir2] < 2000);
//	stopAll();
//	if(sensorValue[ir1] < 2000)
//	{
//		pivotB(-30);
//		while(sensorValue[ir1]< 2000);
//		stopAll();
//	}

//	else if(sensorValue[ir2] < 2000)
//	{
//		pivotA(30);
//		while(sensorValue[ir2]< 2000);

//		stopAll();
//		wait1Msec(2000);// Robot waits for 2000 milliseconds before executing program


//	}
//	while(SensorValue[sonarSensor] > 3)
//	{
//		if(sensorValue[ir2]> 2000)
//		{
//			motor[motorB] = 30;
//		}
//		else if (sensorValue[ir2]< 2000)
//	 {
//			driveX(30);
//		}
//	}
//	stopAll();
//string S;
	//while (true)
	//{ sprintf(S, "%f",SensorValue[sonarSensor]);
	//	clearLCDLine(0);

	//	displayLCDCenteredString( 0,S) ;
	//			wait1Msec(500);
	//}
	// Robot waits for 2000 milliseconds before executing program
	//  motor[leftMotor]  = 120;                             // Move forward at full power for 3 seconds
	//                                 	//motor[rightMotor] = 127;		  // Motor on port2 is run at full (127) power forward
	//// Motor on port3 is run at full (127) power forward
	//	wait1Msec(2000);
	//	motor[leftMotor] = 0;
	//	wait1Msec(3000);
	//	motor[leftMotor] = -120;
	//	wait1Msec(2000);
}
// Robot runs previous code for 3000 milliseconds before moving on
// Program ends, and the robot stops
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
