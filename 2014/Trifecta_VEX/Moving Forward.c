#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,		 ir1,						 sensorLineFollower)
#pragma config(Sensor, in2,		 ir2,						 sensorLineFollower)
#pragma config(Sensor, in3,		 ir3,						 sensorLineFollower)
#pragma config(Sensor, dgtl1,	 sonarSensori,	 sensorSONAR_cm)
#pragma config(Sensor, dgtl3,	 bumperswitch,	 sensorTouch)
#pragma config(Sensor, I2C_1,	 motorA,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Sensor, I2C_2,	 motorB,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Sensor, I2C_3,	 motorC,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Sensor, I2C_4,	 linearT,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Motor,	 port2,						motorA,				 tmotorVex393, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,	 port3,						motorB,				 tmotorVex393, PIDControl, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,	 port4,						motorC,				 tmotorVex393, PIDControl, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,	 port5,						linearT,			 tmotorVex393, PIDControl, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,	 port6,						claw,					 tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*----------------------------------------------------------------------------------------------------*\
|*																				 - Moving Forward -																					*|
|*																			ROBOTC on VEX 2.0 CORTEX																			*|
|*																																																		*|
|*	This program instructs your robot to move forward at full power for three seconds.	There is a		*|
|*	two second pause at the beginning of the program.																									*|
|*																																																		*|
|*																				ROBOT CONFIGURATION																					*|
|*		NOTES:																																													*|
|*		1)	Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the				*|
|*				"Squarebot" mode, but may not be needed for all robot configurations.												*|
|*		2)	Power levels that can be assigned to a motor port range from -127 (full reverse) to					*|
|*				127 (full forward).																																					*|
|*																																																		*|
|*		MOTORS & SENSORS:																																								*|
|*		[I/O Port]					[Name]							[Type]								[Description]											*|
|*		Motor Port 2				rightMotor					VEX 3-wire module			Right side motor									*|
|*		Motor Port 3				leftMotor						VEX 3-wire module			Left side motor										*|
\*-----------------------------------------------------------------------------------------------4246-*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
#define R 112 //mm
#define SENSORTHRUSH 1900
#define COUNT_PER_REV	 627.2
#define PI 3.14159
#define D_WHEEL (2.75*2.54)	 // in cm
#define REV_2_DIST	((PI * D_WHEEL) / COUNT_PER_REV)
#define TABLEHEIGHT 5.5
#define USHEIGHT 12.5
#define BOX_DEPTH 23
bool g_sync = false;
void driveX(int vx)
{
	motor[motorA] =	 vx/2;
	motor[motorB] =	 vx/2;
	motor[motorC] = -vx;

}
void driveXY(long vx, long vy)
{
	motor[motorA] =	 vx/2 + (vy*866)/1000;
	motor[motorB] =	 vx/2 - (vy*866)/1000;
	motor[motorC] = -vx;
}
void driveXYT(long vx, long vy, long vt)
{
	motor[motorA] =	 vx/2 + (vy*866)/1000 - vt;
	motor[motorB] =	 vx/2 - (vy*866)/1000 - vt;
	motor[motorC] = -vx - vt;
}
int distX(bool reset)
{
	static int encA, encB, encC ;
	int dA, dB, dC ;
	if (reset)
	{
		encA = nMotorEncoder[motorA] ;
		encB = nMotorEncoder[motorB] ;
		encC = nMotorEncoder[motorC] ;
	}

	dA = (nMotorEncoder[motorA] - encA)*REV_2_DIST ;
	dB = (nMotorEncoder[motorB] - encB)*REV_2_DIST ;
	dC = (nMotorEncoder[motorC] - encC)*REV_2_DIST ;

	return dA/3 + dB/3 - 2*dC/3 ;
}
void driveY(long vy)
{
	motor[motorA] =	 (vy*866)/1000;
	motor[motorB] = -(vy*866)/1000;
	motor[motorC] =	 0;

}

void pivotA(int v)
{
	motor[motorB] = -v;
	motor[motorC] = -v;

}
void pivotB(int v)
{
	motor[motorA] = -v;
	motor[motorC] = -v;
}
void pivotC(int v)
{
	motor[motorA] = -v;
	motor[motorB] = -v;
}
int rMax(int v1, int v2, int v3)
{
	int vMax;
	if(v1 > v2)vMax = v1;
	else vMax = v2;

	if (v3 > vMax)vMax = v3;
	return vMax;




}
int distY(bool reset)
{
	static int encA, encB;
	int dA, dB,;
	if (reset)
	{
		encA = nMotorEncoder[motorA] ;
		encB = nMotorEncoder[motorB] ;

	}

	dA = (nMotorEncoder[motorA] - encA)*REV_2_DIST ;
	dB = (nMotorEncoder[motorB] - encB)*REV_2_DIST ;


	return dA*.577 - dB*.577;
}
long g_vA, g_vB, g_vC ;	 //globals for the driveABCsync() task



#define SYNC_GAIN_NUM 2
#define SYNC_GAIN_DEN 1

task driveABCsync()
{
	long encA, encB, encC ;
	long dA, dB, dC ;
	long vA, vB, vC ;
	encA = nMotorEncoder[motorA] ;
	encB = nMotorEncoder[motorB] ;
	encC = nMotorEncoder[motorC] ;

	g_sync = true ;

	motor[motorA] = vA = g_vA ;
	motor[motorB] = vB = g_vB ;
	motor[motorC] = vC = g_vC ;
	long sgnA = sgn(g_vA) ;
	long sgnB = sgn(g_vB) ;
	long sgnC = sgn(g_vC) ;
	long savg = ( sgnA*g_vA + sgnB*g_vB + sgnC*g_vC )/3 ;

	while (g_sync)
	{
		wait1Msec(20) ;

		dA = nMotorEncoder[motorA] - encA ;
		dB = nMotorEncoder[motorB] - encB ;
		dC = nMotorEncoder[motorC] - encC ;

		// Compute the average absolute encoder reading
		long davg = ( sgnA*dA + sgnB*dB + sgnC*dC )/3 ;

		// Create reference values for the encoders to track.
		long refA = g_vA*davg/savg ;
		long refB = g_vB*davg/savg ;
		long refC = g_vC*davg/savg ;

		long eA = ( (dA - refA)*SYNC_GAIN_NUM )/SYNC_GAIN_DEN ;
		long eB = ( (dB - refB)*SYNC_GAIN_NUM )/SYNC_GAIN_DEN ;
		long eC = ( (dC - refC)*SYNC_GAIN_NUM )/SYNC_GAIN_DEN ;

		// Clamp the drive commands to -100...+100
		if (eA >	100) eA =	 100 ;
		if (eA < -100) eA = -100 ;
		if (eB >	100) eB =	 100 ;
		if (eB < -100) eB = -100 ;
		if (eC >	100) eC =	 100 ;
		if (eC < -100) eC = -100 ;

		// Deive the motors
		motor[motorA] = vA - eA ;
		motor[motorB] = vB - eB ;
		motor[motorC] = vC - eC ;
	}
}
void driveXYTsync(long vx, long vy, long vt)
{
	g_vA =	vx/2 + (vy*866)/1000 - vt;
	g_vB =	vx/2 - (vy*866)/1000 - vt;
	g_vC = -vx - vt;
	StartTask(driveABCsync) ;
}
void stopAll()
{
	StopTask(driveABCsync);

	g_sync=false;
	motor[motorA] = 0;
	motor[motorB] = 0;
	motor[motorC] = 0;
	motor[claw] = 0;
	motor[linearT] = 0;

}
task eStop()
{
	while(SensorValue(bumperswitch) == 0)
	{
		wait1Msec(10);
	}
	stopAll();
	StopAllTasks();
}
task main()
{
	//*********************************************************************************************************************************
	bLCDBacklight=true;
	displayLCDString(1, 0, " B		B-M			M");
	int button;
	int tme1 = 12;
	string S;
	displayLCDNumber(1, 5, tme1);
	while((button=nLCDButtons)==0){}

  wait1Msec(100);

	while(true)
	{
		displayLCDString(1, 0, " -		 GO			+");
		clearLCDLine (0);
		sprintf(S, "%d",tme1);
		while((button=nLCDButtons)==0){}


		if (button==2) {
			displayLCDString(0, 0, "Go");
			break;
		}
		else if (button==1) {
			tme1--;
			sprintf(S, "%d",tme1);
			displayLCDString(0, 0, S);

			//sprintf(S, "%d",tme1);
			//displayLCDCenteredString(0, S);
		}
		else if (button==4) {
			tme1++;
			sprintf(S, "%d",tme1);
			displayLCDString(0, 0, S);


		}
		else if (tme1 > 14) {
			tme1= 14;

		}
		else if (tme1 > 12) {
			tme1= 12;
			break;
		}
		sprintf(S, "%d",tme1);
		displayLCDCenteredString(0, S);
		wait1Msec(500);
	}

	wait1Msec(1000);
	displayLCDCenteredString(0, S);
	//********************************************************************************************************************************
	while(true)
	{

		nMotorEncoder[motorA] = 0;
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorC] = 0;
		nMotorEncoder[claw] = 0;
		nMotorEncoder[linearT] = 0;
		string S;
		while(nLCDButtons == 0) {}
		StartTask(eStop);

		wait1Msec(2000);

		//drive across table
		if (tme1 == 10)
		{
			pivotC(-30);
			wait1Msec(500);
			StopAll();
		}

		else if (tme1 == 11)
		{
			pivotC(-30);
			wait1Msec(250);
			StopAll();
		}

		else if (tme1 == 13)
		{
			pivotC(30);
			wait1Msec(250);
			StopAll();
		}

		else if	 (tme1 == 14)
		{
			pivotC(30);
			wait1Msec(500);
			StopAll();
		}

		distY(true);
		driveY(30);
		while(sensorValue[ir1]< SENSORTHRUSH && sensorValue[ir2] < SENSORTHRUSH);
		stopAll();
		sprintf(S, "%d",distY(false));
		long dy = distY(false);
		displayLCDCenteredString(0, S);
		wait1Msec(3000);
		distX(true);
		//follow edge to box
		while(true)
		{
			int x1 = SensorValue[sonarSensori];
			wait1Msec(10);
			int x2 = SensorValue[sonarSensori];
			wait1Msec(10);
			int x3 = SensorValue[sonarSensori];
			if(rMax(x1,x2,x3) < 10)
				break;
			sprintf(S, "%f",SensorValue[sonarSensori]);
			displayLCDCenteredString(0, S);
			int ey;
			int et;
			int s1 = sensorValue[ir1];
			int s2 = sensorValue[ir2];
			ey = (s1 + s2)/2 - 2000;
			et = (s2 - s1)/2;
			driveXYT(30,-ey/150,-et/150 );
		}
		stopAll();
		motor[claw] = 50;
		wait1Msec(1000);
		stopAll();
		time1[T1] = 0;

		while(true)
		{

			if(time1[T1] > 1000)
				break;
			int ey = 0;
			int et= 0;
			int s1 = sensorValue[ir1];
			int s2 = sensorValue[ir2];
			//distX(true);
			ey = (s1 + s2)/2 - 2000;
			et = (s2 - s1)/2;
			driveXYT(30,-ey/150,-et/150 );
			sprintf(S, "%d",distX(false));
			displayLCDCenteredString(0, S);
		}

		stopAll();

		long linT = nMotorEncoder[linearT];
		while(SensorValue[sonarSensori] < 15)
		{
			motor[linearT] = -40;
		}
		stopAll();
		long linZ = nMotorEncoder[linearT];
		long lind = linZ - linT;
		long height=(-lind/156.8)- 1.5 + USHEIGHT + TABLEHEIGHT;
		sprintf(S, "%d",height);
		clearLCDLine(0);
		displayLCDCenteredString(0, S);

		wait1Msec(1000);
		motor[linearT] = 30;
		wait1Msec(1000);
		stopAll();
		long dx = distX(false);
		long width1 = dx;
		int ey;
		int et;
		while(SensorValue[sonarSensori] < 30)
		{
			int s1 = SensorValue[ir1];
			int s2 = SensorValue[ir2];
			ey = (s1 + s2)/2 - 2000;
			et = (s2 - s1)/2;
			driveXYT(30,-ey/150,-et/150);
		}
		stopAll();
		dx = distX(false);
		long width2 = distX(false);
		long width3 = width2 - width1;
		long volme = width3 * height* BOX_DEPTH;
		sprintf(S, "%d",volme);
		clearLCDLine(0);
		displayLCDCenteredString(0, S);
		wait1Msec(10000);
		sprintf(S, "%d",width3);
		clearLCDLine(1);
		displayLCDCenteredString(1, S);

		float T = sqrt(dx*dx + dy*dy);
		float Tx = dx/T;
		float Ty = dy/T;
		//sprintf(S, "%d",Tx);

		long cmdx = (-Tx*35);
		long cmdy = (-Ty*35);
		driveXYTsync(cmdx, cmdy, 0) ;
		//displayLCDCenteredString(0, S);
		while (sensorValue[ir3]< 1900)
		{
		}
		stopAll();
		clearLCDLine(1);
		displayLCDCenteredString(1, S);
		Wait1Msec(10000);
		//sprintf(S, "%d",distX(false));
		//float XYdist=
	}

	//	while(SensorValue[sonarSensor] > 3)
	//	{
	//		if(sensorValue[ir2]> 2000)
	//		{
	//			motor[motorB] = 30;
	//		}
	//		else if (sensorValue[ir2]< 2000)
	//	 {
	//			driveX(30);
	//		}
	//	}
	//	stopAll();
	//string S;
	//while (true)
	//{ sprintf(S, "%f",SensorValue[sonarSensor]);
	//	clearLCDLine(0);

	//	displayLCDCenteredString( 0,S) ;
	//			wait1Msec(500);
	//}
	// Robot waits for 2000 milliseconds before executing program
	//	motor[leftMotor]	= 120;														 // Move forward at full power for 3 seconds
	//																	//motor[rightMotor] = 127;			// Motor on port2 is run at full (127) power forward
	//// Motor on port3 is run at full (127) power forward
	//	wait1Msec(2000);
	//	motor[leftMotor] = 0;
	//	wait1Msec(3000);
	//	motor[leftMotor] = -120;
	//	wait1Msec(2000);
}
// Robot runs previous code for 3000 milliseconds before moving on
// Program ends, and the robot stops
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
