#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ir1,            sensorLineFollower)
#pragma config(Sensor, in2,    ir2,            sensorLineFollower)
#pragma config(Sensor, in3,    ir3,            sensorLineFollower)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           motorA,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           motorB,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           motorC,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_3, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Moving Forward -                                         *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs your robot to move forward at full power for three seconds.  There is a    *|
|*  two second pause at the beginning of the program.                                                 *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Power levels that can be assigned to a motor port range from -127 (full reverse) to         *|
|*        127 (full forward).                                                                         *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor Port 2        rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor Port 3        leftMotor           VEX 3-wire module     Left side motor                   *|
\*-----------------------------------------------------------------------------------------------4246-*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
#define R 112 //mm

#define COUNT_PER_REV  627.2
#define PI 3.14159
#define D_WHEEL (2.75*25.4)  // in mm
#define REV_2_DIST  ((PI * D_WHEEL) / COUNT_PER_REV)
#define P_TO_TPMS 0.0139  // Power to ticks per milisecond

void driveX(int vx)
{
	motor[motorA] =  vx/2;
	motor[motorB] =  vx/2;
	motor[motorC] = -vx;

}

long g_vA, g_vB, g_vC ;  //globals for the driveABCsync() task
bool g_sync = false ;


#define SYNC_GAIN_NUM 2
#define SYNC_GAIN_DEN 1

task driveABCsync()
{
	long encA, encB, encC ;
	long dA, dB, dC ;
	long vA, vB, vC ;
	encA = nMotorEncoder[motorA] ;
	encB = nMotorEncoder[motorB] ;
	encC = nMotorEncoder[motorC] ;

	g_sync = true ;

	motor[motorA] = vA = g_vA ;
	motor[motorB] = vB = g_vB ;
	motor[motorC] = vC = g_vC ;
	long sgnA = sgn(g_vA) ;
	long sgnB = sgn(g_vB) ;
	long sgnC = sgn(g_vC) ;
	long savg = ( sgnA*g_vA + sgnB*g_vB + sgnC*g_vC )/3 ;

	while (g_sync)
	{
		wait1Msec(20) ;

		dA = nMotorEncoder[motorA] - encA ;
		dB = nMotorEncoder[motorB] - encB ;
		dC = nMotorEncoder[motorC] - encC ;

		// Compute the average absolute encoder reading
		long davg = ( sgnA*dA + sgnB*dB + sgnC*dC )/3 ;

		// Create reference values for the encoders to track.
		long refA = g_vA*davg/savg ;
		long refB = g_vB*davg/savg ;
		long refC = g_vC*davg/savg ;

		long eA =  (dA - refA)/1000 ;
		long eB =  (dB - refB)/1000 ;
		long eC =  (dC - refC)/1000 ;

		// Clamp the drive commands to -100...+100
		if (eA >  100) eA =  100 ;
		if (eA < -100) eA = -100 ;
		if (eB >  100) eB =  100 ;
		if (eB < -100) eB = -100 ;
		if (eC >  100) eC =  100 ;
		if (eC < -100) eC = -100 ;

		// Deive the motors
		motor[motorA] = vA - eA ;
		motor[motorB] = vB - eB ;
		motor[motorC] = vC - eC ;
	}
	motor[motorA] = 0 ;
	motor[motorB] = 0 ;
	motor[motorC] = 0 ;

}
#define SYNC_TIC_MS 20
task driveABCposSync()
{
	long encA, encB, encC ;
	long dA, dB, dC ;
	long vA, vB, vC ;
	long iA = 0 ; // integral of the error
	long iB = 0 ;
	long iC = 0 ;
	encA = nMotorEncoder[motorA] ;
	encB = nMotorEncoder[motorB] ;
	encC = nMotorEncoder[motorC] ;
	float speedA = (P_TO_TPMS * g_vA) ;
	float speedB = (P_TO_TPMS * g_vB) ;
	float speedC = (P_TO_TPMS * g_vC) ;

	long tA = 0 ;
	long tB = 0 ;
	long tC = 0 ;
	long tA0, tB0, tC0 ;

	g_sync = true ;

	long ts = time1[T1] ;
	motor[motorC] = vC = g_vC ;
	motor[motorB] = vB = g_vB ;
	motor[motorA] = vA = g_vA ;
	long t = 0 ; // current time
	long t_1 ;  // last time
		long t0 ;  // last time

	long dt ; // time difference

#define NSTARTRAMP 25
	int n = 0 ;
	while (g_sync)
	{
		wait1Msec(20) ;

		// update time
		t_1 = t ;
		t = time1[T1] - ts ;

		// setup the target distances
		if (n < NSTARTRAMP)
		{
			dt = t - t_1 ;
			tA += speedA*n*dt/NSTARTRAMP ;
			tB += speedB*n*dt/NSTARTRAMP ;
			tC += speedC*n*dt/NSTARTRAMP ;
			tA0 = tA ;
			tB0 = tB ;
			tC0 = tC ;
			n++ ;
			t0 = t ;
		}
		else
		{
			tA = speedA*(t - t0) + tA0 ;
			tB = speedB*(t - t0) + tB0 ;
			tC = speedC*(t - t0) + tC0 ;
		}

		dA = nMotorEncoder[motorA] - encA ;
		dB = nMotorEncoder[motorB] - encB ;
		dC = nMotorEncoder[motorC] - encC ;

		long eA = dA - tA ;
		long eB = dB - tB ;
		long eC = dC - tC ;
		iA += eA ;
		iB += eB ;
		iC += eC ;
		long cA = (long)(eA*0.8 + iA*0.01) ;
		long cB = (long)(eB*0.8 + iB*0.01) ;
		long cC = (long)(eC*0.8 + iC*0.01) ;

		// Clamp the drive commands to -100...+100
		if (cA >  100) cA =  100 ;
		if (cA < -100) cA = -100 ;
		if (cB >  100) cB =  100 ;
		if (cB < -100) cB = -100 ;
		if (cC >  100) cC =  100 ;
		if (cC < -100) cC = -100 ;

		// Drive the motors
		motor[motorC] = vC - cC ;
		motor[motorB] = vB - cB ;
		motor[motorA] = vA - cA ;
	}
	motor[motorA] = 0 ;
	motor[motorB] = 0 ;
	motor[motorC] = 0 ;

}
void driveXsync(long vx)
{
	g_vA =  vx/2;
	g_vB =  vx/2;
	g_vC = -vx;
	StartTask(driveABCsync) ;
}
void driveXposSync(long vx)
{
	g_vA =  vx/2;
	g_vB =  vx/2;
	g_vC = -vx;
	StartTask(driveABCposSync) ;
}
void driveYsync(long vy)
{
	g_vA =  (vy*866)/1000;
	g_vB = -(vy*866)/1000;
	g_vC =  0;
	StartTask(driveABCsync) ;
}
void driveYposSync(long vy)
{
	g_vA =  (vy*866)/1000;
	g_vB = -(vy*866)/1000;
	g_vC =  0;
	StartTask(driveABCposSync) ;
}
void driveXYsync(long vx, long vy)
{
	g_vA =  (long) (vx/2 + vy*0.866) ;
	g_vB =  (long) (vx/2 - vy*0.866) ;
	g_vC = -vx ;
	StartTask(driveABCsync) ;
}
void driveXYposSync(long vx, long vy)
{
	g_vA =  (long) (vx/2 + vy*0.866) ;
	g_vB =  (long) (vx/2 - vy*0.866) ;
	g_vC = -vx ;
	StartTask(driveABCposSync) ;
}
void driveXYTsync(long vx, long vy, long vt)
{
	g_vA =  vx/2 + (vy*866)/1000 - vt;
	g_vB =  vx/2 - (vy*866)/1000 - vt;
	g_vC = -vx - vt;
	StartTask(driveABCsync) ;
}
void driveXY(long vx, long vy)
{
	motor[motorA] =  vx/2 + (vy*866)/1000;
	motor[motorB] =  vx/2 - (vy*866)/1000;
	motor[motorC] = -vx;
}
void driveXYT(long vx, long vy, long vt)
{
	motor[motorA] =  vx/2 + (vy*866)/1000 - vt;
	motor[motorB] =  vx/2 - (vy*866)/1000 - vt;
	motor[motorC] = -vx - vt;
}
int distX(bool reset)
{
	static int encA, encB, encC ;
	int dA, dB, dC ;
	if (reset)
	{
		encA = nMotorEncoder[motorA] ;
		encB = nMotorEncoder[motorB] ;
		encC = nMotorEncoder[motorC] ;
	}

	dA = (nMotorEncoder[motorA] - encA)*REV_2_DIST ;
	dB = (nMotorEncoder[motorB] - encB)*REV_2_DIST ;
	dC = (nMotorEncoder[motorC] - encC)*REV_2_DIST ;

	return dA/3 + dB/3 - 2*dC/3 ;
}
void driveY(long vy)
{
	motor[motorA] =  (vy*866)/1000;
	motor[motorB] = -(vy*866)/1000;
	motor[motorC] =  0;

}
void stopAll()
{
	motor[motorA] = 0;
	motor[motorB] = 0;
	motor[motorC] = 0;
	g_sync = false ;
}
void pivotA(int v)
{
	motor[motorB] = -v;
	motor[motorC] = -v;

}
void pivotB(int v)
{
	motor[motorA] = -v;
	motor[motorC] = -v;

}
task main()
{

	while(nLCDButtons == 0) {}

	wait1Msec(2000);



	//drive across table
	driveXposSync(25);
		//driveXYposSync(30, 30);
	wait1Msec(3000) ;
	stopAll() ;	wait1Msec(300) ;

	driveYposSync(25);
	wait1Msec(3000) ;
	stopAll() ;	wait1Msec(300) ;

	driveXYposSync(-25, -25);
	wait1Msec(3000) ;

	stopAll() ;

}
// Robot runs previous code for 3000 milliseconds before moving on
// Program ends, and the robot stops
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
