#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,		 ir1,						 sensorLineFollower)
#pragma config(Sensor, in2,		 ir2,						 sensorLineFollower)
#pragma config(Sensor, in3,		 ir3,						 sensorLineFollower)
#pragma config(Sensor, dgtl1,	 sonarSensori,	 sensorSONAR_cm)
#pragma config(Sensor, dgtl3,	 bumperswitch,	 sensorTouch)
#pragma config(Sensor, I2C_1,	 motorA,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Sensor, I2C_2,	 motorB,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Sensor, I2C_3,	 motorC,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Sensor, I2C_4,	 linearT,				 sensorQuadEncoderOnI2CPort,		, AutoAssign)
#pragma config(Motor,	 port2,						motorA,				 tmotorVex393, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,	 port3,						motorB,				 tmotorVex393, PIDControl, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,	 port4,						motorC,				 tmotorVex393, PIDControl, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,	 port5,						linearT,			 tmotorVex393, PIDControl, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,	 port6,						claw,					 tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*----------------------------------------------------------------------------------------------------*\
|*																				 - Moving Forward -																					*|
|*																			ROBOTC on VEX 2.0 CORTEX																			*|
|*																																																		*|
|*	This program instructs your robot to move forward at full power for three seconds.	There is a		*|
|*	two second pause at the beginning of the program.																									*|
|*																																																		*|
|*																				ROBOT CONFIGURATION																					*|
|*		NOTES:																																													*|
|*		1)	Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the				*|
|*				"Squarebot" mode, but may not be needed for all robot configurations.												*|
|*		2)	Power levels that can be assigned to a motor port range from -127 (full reverse) to					*|
|*				127 (full forward).																																					*|
|*																																																		*|
|*		MOTORS & SENSORS:																																								*|
|*		[I/O Port]					[Name]							[Type]								[Description]											*|
|*		Motor Port 2				rightMotor					VEX 3-wire module			Right side motor									*|
|*		Motor Port 3				leftMotor						VEX 3-wire module			Left side motor										*|
\*-----------------------------------------------------------------------------------------------4246-*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
//W=39
//H=26
//32448,    31028.4
//if anyboby other than trifecta is reading this DEATH will come!!!
#define R 112 //mm
#define SENSORTHRUSH 1950
#define COUNT_PER_REV	 627.2
#define PI 3.14159
#define D_WHEEL (2.75*2.54)	 // in cm
#define REV_2_DIST	((PI * D_WHEEL) / COUNT_PER_REV)
#define TABLEHEIGHT 4.5
#define USHEIGHT 10
#define BOX_DEPTH 30.6
bool g_sync = false;

// Power to ticks per milisecond
#define P_TO_TPMS 0.0139
void driveX(int vx)
{
	motor[motorA] =	 vx/2;
	motor[motorB] =	 vx/2;
	motor[motorC] = -vx;
}
void driveXY(long vx, long vy)
{
	motor[motorA] =	 vx/2 + (vy*866)/1000;
	motor[motorB] =	 vx/2 - (vy*866)/1000;
	motor[motorC] = -vx;
}
void driveXYT(long vx, long vy, long vt)
{
	motor[motorA] =	 vx/2 + (vy*866)/1000 - vt;
	motor[motorB] =	 vx/2 - (vy*866)/1000 - vt;
	motor[motorC] = -vx - vt;
}

float distX(bool reset)
{
	static int encA, encB, encC ;
	float dA, dB, dC ;
	if (reset)
	{
		encA = nMotorEncoder[motorA] ;
		encB = nMotorEncoder[motorB] ;
		encC = nMotorEncoder[motorC] ;
	}

	dA = (nMotorEncoder[motorA] - encA)*REV_2_DIST ;
	dB = (nMotorEncoder[motorB] - encB)*REV_2_DIST ;
	dC = (nMotorEncoder[motorC] - encC)*REV_2_DIST ;

	return dA/3 + dB/3 - 2*dC/3 ;
}
void driveY(long vy)
{
	motor[motorA] =	 (vy*866)/1000;
	motor[motorB] = -(vy*866)/1000;
	motor[motorC] =	 0;

}

void pivotA(int v)
{
	motor[motorB] = -v;
	motor[motorC] = -v;

}
void pivotB(int v)
{
	motor[motorA] = -v;
	motor[motorC] = -v;
}
void pivotC(int v)
{
	motor[motorA] = -v;
	motor[motorB] = -v;
}
int rMax(int v1, int v2, int v3)
{
	int vMax;
	if(v1 > v2)vMax = v1;
	else vMax = v2;

	if (v3 > vMax)vMax = v3;
	return vMax;




}
float distY(bool reset)
{
	static int encA, encB;
	float dA, dB,;
	if (reset)
	{
		encA = nMotorEncoder[motorA] ;
		encB = nMotorEncoder[motorB] ;

	}

	dA = (nMotorEncoder[motorA] - encA)*REV_2_DIST ;
	dB = (nMotorEncoder[motorB] - encB)*REV_2_DIST ;


	return dA*.577 - dB*.577;
}
long g_vA, g_vB, g_vC ;	 //globals for the driveABCsync() task

#define SYNC_TIC_MS 20
task driveABCposSync()
{
	long encA, encB, encC ;
	long dA, dB, dC ;
	long vA, vB, vC ;
	long iA = 0 ; // integral of the error
	long iB = 0 ;
	long iC = 0 ;
	encA = nMotorEncoder[motorA] ;
	encB = nMotorEncoder[motorB] ;
	encC = nMotorEncoder[motorC] ;
	float speedA = (P_TO_TPMS * g_vA) ;
	float speedB = (P_TO_TPMS * g_vB) ;
	float speedC = (P_TO_TPMS * g_vC) ;

	long tA = 0 ;
	long tB = 0 ;
	long tC = 0 ;
	long tA0, tB0, tC0 ;

	g_sync = true ;

	long ts = time1[T1] ;
	motor[motorC] = vC = g_vC ;
	motor[motorB] = vB = g_vB ;
	motor[motorA] = vA = g_vA ;
	long t = 0 ; // current time
	long t_1 ;	// last time
	long t0 ;	 // last time

	long dt ; // time difference

#define NSTARTRAMP 25
	int n = 0 ;
	while (g_sync)
	{
		wait1Msec(20) ;

		// update time
		t_1 = t ;
		t = time1[T1] - ts ;

		// setup the target distances
		if (n < NSTARTRAMP)
		{
			dt = t - t_1 ;
			tA += speedA*n*dt/NSTARTRAMP ;
			tB += speedB*n*dt/NSTARTRAMP ;
			tC += speedC*n*dt/NSTARTRAMP ;
			tA0 = tA ;
			tB0 = tB ;
			tC0 = tC ;
			n++ ;
			t0 = t ;
		}
		else
		{
			tA = speedA*(t - t0) + tA0 ;
			tB = speedB*(t - t0) + tB0 ;
			tC = speedC*(t - t0) + tC0 ;
		}

		dA = nMotorEncoder[motorA] - encA ;
		dB = nMotorEncoder[motorB] - encB ;
		dC = nMotorEncoder[motorC] - encC ;

		long eA = dA - tA ;
		long eB = dB - tB ;
		long eC = dC - tC ;
		iA += eA ;
		iB += eB ;
		iC += eC ;
		long cA = (long)(eA*0.8 + iA*0.01) ;
		long cB = (long)(eB*0.8 + iB*0.01) ;
		long cC = (long)(eC*0.8 + iC*0.01) ;

		// Clamp the drive commands to -100...+100
		if (cA >	100) cA =	 100 ;
		if (cA < -100) cA = -100 ;
		if (cB >	100) cB =	 100 ;
		if (cB < -100) cB = -100 ;
		if (cC >	100) cC =	 100 ;
		if (cC < -100) cC = -100 ;

		// Drive the motors
		motor[motorC] = vC - cC ;
		motor[motorB] = vB - cB ;
		motor[motorA] = vA - cA ;
	}
	motor[motorA] = 0 ;
	motor[motorB] = 0 ;
	motor[motorC] = 0 ;

}

void driveXposSync(long vx)
{
	g_vA =	vx/2;
	g_vB =	vx/2;
	g_vC = -vx;
	StartTask(driveABCposSync) ;
}

void driveYposSync(long vy)
{
	g_vA =	(vy*866)/1000;
	g_vB = -(vy*866)/1000;
	g_vC =	0;
	StartTask(driveABCposSync) ;

}
#define SYNC_GAIN_NUM 2
#define SYNC_GAIN_DEN 1

task driveABCsync()
{
	long encA, encB, encC ;
	long dA, dB, dC ;
	long vA, vB, vC ;
	encA = nMotorEncoder[motorA] ;
	encB = nMotorEncoder[motorB] ;
	encC = nMotorEncoder[motorC] ;

	g_sync = true ;

	motor[motorA] = vA = g_vA ;
	motor[motorB] = vB = g_vB ;
	motor[motorC] = vC = g_vC ;
	long sgnA = sgn(g_vA) ;
	long sgnB = sgn(g_vB) ;
	long sgnC = sgn(g_vC) ;
	long savg = ( sgnA*g_vA + sgnB*g_vB + sgnC*g_vC )/3 ;

	while (g_sync)
	{
		wait1Msec(20) ;

		dA = nMotorEncoder[motorA] - encA ;
		dB = nMotorEncoder[motorB] - encB ;
		dC = nMotorEncoder[motorC] - encC ;

		// Compute the average absolute encoder reading
		long davg = ( sgnA*dA + sgnB*dB + sgnC*dC )/3 ;

		// Create reference values for the encoders to track.
		long refA = g_vA*davg/savg ;
		long refB = g_vB*davg/savg ;
		long refC = g_vC*davg/savg ;

		long eA = ( (dA - refA)*SYNC_GAIN_NUM )/SYNC_GAIN_DEN ;
		long eB = ( (dB - refB)*SYNC_GAIN_NUM )/SYNC_GAIN_DEN ;
		long eC = ( (dC - refC)*SYNC_GAIN_NUM )/SYNC_GAIN_DEN ;

		// Clamp the drive commands to -100...+100
		if (eA >	100) eA =	 100 ;
		if (eA < -100) eA = -100 ;
		if (eB >	100) eB =	 100 ;
		if (eB < -100) eB = -100 ;
		if (eC >	100) eC =	 100 ;
		if (eC < -100) eC = -100 ;

		// Deive the motors
		motor[motorA] = vA - eA ;
		motor[motorB] = vB - eB ;
		motor[motorC] = vC - eC ;
	}
}

void driveXYposSync(long vx, long vy)
{
	g_vA =	(long) (vx/2 + vy*0.866) ;
	g_vB =	(long) (vx/2 - vy*0.866) ;
	g_vC = -vx ;
	StartTask(driveABCposSync) ;
}

void driveXYTsync(long vx, long vy, long vt)
{
	g_vA =	vx/2 + (vy*866)/1000 - vt;
	g_vB =	vx/2 - (vy*866)/1000 - vt;
	g_vC = -vx - vt;
	StartTask(driveABCsync) ;
}
void driveXYTposSync(long vx, long vy, long vt)
{
	g_vA =	vx/2 + (vy*866)/1000 - vt;
	g_vB =	vx/2 - (vy*866)/1000 - vt;
	g_vC = -vx - vt;
	StartTask(driveABCposSync) ;
}

void stopAll()
{
	StopTask(driveABCsync);

	g_sync=false;
	motor[motorA] = 0;
	motor[motorB] = 0;
	motor[motorC] = 0;
	motor[claw] = 0;
	motor[linearT] = 0;

}

task eStop()
{
	while(SensorValue(bumperswitch) == 0)
	{
		wait1Msec(10);
	}
	stopAll();
	StopAllTasks();
}
double g_volume = 0;

void printVolume()
{
	string S = "";
	sprintf(S, "volume= %d",g_Volume);
	displayLCDCenteredString(0,S);
}
//###################################################################################################################################
//###################################################################################################################################
//###################################################################################################################################
//##############################################task main############################################################################
task main()
{
	bool firstTime = true;
	//display
	//*********************************************************************************************************************************

	while (true)

	{

		bLCDBacklight=true;
		displayLCDString(1, 0, " B		B-M			M");
		bool ball;
		bool measure;
		int button;
		int tme1 = 12;
		int x;
		string S;
		displayLCDNumber(1, 5, tme1);
		while((button=nLCDButtons)==0){}

		// choose direction
		if (button == 1)
		{
			ball = true;
			measure = false;
		}
		else if (button == 2)
		{
			ball = true;
			measure = true;
		}
		else if (button == 4)
		{
			ball = false;
			measure = true;
		}
		wait1Msec(250);

		while(true)
		{

			displayLCDString(1, 0, " -		 GO			+");

			sprintf(S, "%d",tme1);
			while((button=nLCDButtons)==0){}


			if (button==2) {
				displayLCDString(0, 0, "Go");
				clearLCDLine (0);
				break;
			}

			else if (button==1) {
				tme1--;
				sprintf(S, "%d",tme1);
				clearLCDLine (0);
				displayLCDString(0, 0, S);
			}

			else if (button==4) {
				tme1++;
				sprintf(S, "%d",tme1);
				clearLCDLine (0);
				displayLCDString(0, 0, S);


			}
			else if (tme1 > 14) {
				tme1= 14;
        clearLCDLine (0);
			}
			else if (tme1 > 12) {
				tme1= 12;
				clearLCDLine (0);
				break;
			}
			sprintf(S, "%d",tme1);
			displayLCDCenteredString(0, S);
			wait1Msec(500);
		}

		wait1Msec(1000);
		displayLCDCenteredString(0, S);


		//********************************************************************************************************************************
		//end of display

		nMotorEncoder[motorA] = 0;
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorC] = 0;
		nMotorEncoder[claw] = 0;
		nMotorEncoder[linearT] = 0;
		StartTask(eStop);
		wait1Msec(500);
		long cmdx;
		long cmdy;
		//drive across table

		if (tme1 == 10)
		{
			pivotC(-30);
			wait1Msec(1000);
			stopAll();
		}

		else if (tme1 == 11)
		{
			pivotC(-30);
			wait1Msec(600);
			stopAll();
		}

		else if (tme1 == 13)
		{
			pivotC(30);
			wait1Msec(600);
			stopAll();
		}

		else if	 (tme1 == 14)
		{
			pivotC(30);
			wait1Msec(1000);
			stopAll();
		}
		long dy;
    long cmdx2;
    long cmdy2;
    	long eiy = 0;
			long eit = 0;
			long dx1;
			long dx2;
		if (firstTime)
		{
			distY(true);
			driveYposSync(35);
			while(SensorValue[ir1]< SENSORTHRUSH && SensorValue[ir2] < SENSORTHRUSH)
			{
			}
			stopAll();
			//sprintf(S, "%d",distY(false));
			dy = distY(false);
			//displayLCDCenteredString(0, S);
			wait1Msec(500);
			distX(true);



			//		else if (firstTime = false);
			//driveXYTsync(-cmdx, -cmdy, 0);
			// start running driving in the Y direction "cheese"

			//follow edge to box

			while(true)
			{
				int x1 = SensorValue[sonarSensori];
				wait1Msec(10);
				int x2 = SensorValue[sonarSensori];
				wait1Msec(10);
				int x3 = SensorValue[sonarSensori];
				if(rMax(x1,x2,x3) < 10)
					break;
				//sprintf(S, "%f",SensorValue[sonarSensori]);
				//displayLCDCenteredString(0, S);
				int ey;
				int et;
				int s1 = SensorValue[ir1];
				int s2 = SensorValue[ir2];
				ey = (s1 + s2)/2 - 2000;
				et = (s2 - s1)/2;
				eiy = eiy + ey;
				eit = eit + et;
				//int cy = -ey/150 -eiy/1500;
				int cy = -ey/150;
				int ct = -et/150 - eit/2000;
				driveXYT(30,cy,ct);
			}
			stopAll();
		dx1 = distX(false);
    float T = sqrt(dx1*dx1 + dy*dy);
		float Tx = dx1/T;
		float Ty = dy/T;
		cmdx2 = (Tx*37);
		cmdy2 = (Ty*37);
		//
			firstTime = false;
		}// end of if first time

else
{
	driveXYTposSync(cmdx2, cmdy2, 0);
	while(SensorValue[ir1]< SENSORTHRUSH && SensorValue[ir2] < SENSORTHRUSH)
			{
			}
      stopAll();
		DriveXYTposSync(30,0,0);
	while(SensorValue[sonarSensori] > 10)
			{
			}
			StopAll();
}

		//dropping the ball
	  printVolume()
    if (ball)
		{
			motor[claw] = 50;
			wait1Msec(500);
			stopAll();
		}
		float dx;

		//measuring the box
		if (measure)
		{
			time1[T1] = 0;
			float dx1 = 0;
			dx1 = distX(false);

			while(true)
			{
				// drive forward for 1 sec
				if(time1[T1] > 1000)
					break;
				int ey = 0;
				int et= 0;
				int s1 = SensorValue[ir1];
				int s2 = SensorValue[ir2];
				ey = (s1 + s2)/2 - 2000;
				et = (s2 - s1)/2;
				driveXYT(30,-ey/150,-et/150 );
				//sprintf(S, "%d",distX(false));
				//displayLCDCenteredString(0, S);
			}//while true end
			stopAll();

			long linT = nMotorEncoder[linearT];
			while(SensorValue[sonarSensori] < 10)
			{
				motor[linearT] = -40;
			}
			stopAll();

			long linZ = nMotorEncoder[linearT];
			long lind = linZ - linT;
      //sprintf(S, "%f",lind);
			//clearLCDLine(1);
			//displayLCDCenteredString(0,S);
			// computing the hieght
			double height=(-lind/156.8)- 1.5 + USHEIGHT + TABLEHEIGHT;
			sprintf(S, "height=%f",height);

			clearLCDLine(1);
			displayLCDCenteredString(1, S);

			// measure the width of the box
			wait1Msec(750);
			motor[linearT] = 30;
			wait1Msec(500);
			stopAll();
			dx = distX(false);
			long width1 = dx;
			int ey;
			int et;
			long eit = 0;
			long eiy = 0;
			while(SensorValue[sonarSensori] < 30)
			{
				int s1 = SensorValue[ir1];
				int s2 = SensorValue[ir2];
				ey = (s1 + s2)/2 - 2000;
				et = (s2 - s1)/2;
				eiy = eiy + ey;
				eit = eit + et;
				//int cy = -ey/150 -eiy/1500;
				long cy = -ey/200;
				long ct = -et/100;
				if (ct > 100 )ct = 100;
				if (ct < -100 )ct = -100;
				driveXYTposSync(30,cy,ct);
			}// while end
			stopAll();//stopdriveXYTposSync

			dx = distX(false) - dx1;

			wait1Msec(1000);
			double width2 = distX(false);
			double width3 = width2 - width1;
			width3 = width3 + 2;
			sprintf(S, "width=%f",width3);
			clearLCDLine(1);
		  displayLCDCenteredString(1, S);
			double volme = width3 * height* BOX_DEPTH;
			g_volume = volme;
			//sprintf(S, "%f",volme);
			//displayLCDCenteredString(0, S);
			wait1Msec(1000);
			stopAll();
		}//if end

		//drive home for cheese
		dx = distX(false);
		float T = sqrt(dx*dx + dy*dy);
		float Tx = dx/T;
		float Ty = dy/T;
		cmdx = (-Tx*37);
		cmdy = (-Ty*37);
		driveXYTposSync(cmdx, cmdy, 0);
		printVolume();
		while (SensorValue[ir3]< 1900)
		{
			//eat cheese
		}
		driveXYTsync(0,0,0);
		stopAll();
		wait1Msec(500);
		long rt =  time1[T2] = 0;
		// follow the edge
		printVolume()
		while(time1[T2])
		{
			int x1 = SensorValue[sonarSensori];
			wait1Msec(10);
			int x2 = SensorValue[sonarSensori];
			wait1Msec(10);
			int x3 = SensorValue[sonarSensori];
			if(rMax(x1,x2,x3) < 10)
				break;
			int ey;
			int et;
			int s1 = SensorValue[ir1];
			int s2 = SensorValue[ir2];
			ey = (s1 + s2)/2 - 2000;
			eiy = eiy + ey;
			//int cy = -ey/150 -eiy/1500;
			int cy = -ey/150;
			driveXY(30,cy);
			wait1Msec(1000);
		}
		stopAll();
		long t0 = time1[T1];

		while(true)
			{
				long t1 = time1[T1] -t0;
				if (t1 > 1500) break;
				int ey;
				int s3 = SensorValue[ir3];
				ey = s3 - 2000;
				int cy = ey/150;
				driveXY(-30,cy);
			}
			stopAll();
		//clearLCDLine(1);
		//displayLCDCenteredString(1, S);
		x++;
		printVolume()
	}
	wait1Msec(1500);
}// while loop end
// task main end
// Program ends, and the robot stops
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// stop eating cheese
